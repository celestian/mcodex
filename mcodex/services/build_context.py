from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any

from mcodex.metadata import load_metadata
from mcodex.yaml_utils import safe_dump_yaml, safe_load_yaml


@dataclass(frozen=True)
class BuildContextResult:
    context: dict[str, Any]
    yaml_path: Path
    header_md_path: Path
    latex_context_path: Path


def _load_optional_yaml(path: Path) -> dict[str, Any] | None:
    if not path.exists():
        return None
    return safe_load_yaml(path)


def _authors_as_nicknames(meta: dict[str, Any]) -> list[str]:
    authors = meta.get("authors")
    if not isinstance(authors, list):
        return []
    out: list[str] = []
    for a in authors:
        if not isinstance(a, dict):
            continue
        nick = a.get("nickname")
        if isinstance(nick, str) and nick.strip():
            out.append(nick.strip())
    return out


def _format_header_md(context: dict[str, Any]) -> str:
    title = str(context.get("title") or "").strip() or "(untitled)"
    authors = context.get("author")
    if isinstance(authors, list):
        authors_line = ", ".join(str(a) for a in authors if str(a).strip())
    else:
        authors_line = str(authors or "").strip()

    meta_lines: list[str] = []
    if authors_line:
        meta_lines.append(f"**Authors:** {authors_line}")

    snapshot_label = context.get("snapshot_label")
    if isinstance(snapshot_label, str) and snapshot_label.strip():
        meta_lines.append(f"**Snapshot:** {snapshot_label.strip()}")
    else:
        version = context.get("build", {}).get("version")
        if isinstance(version, str) and version.strip():
            meta_lines.append(f"**Version:** {version.strip()}")

    built_at = context.get("build", {}).get("built_at")
    if isinstance(built_at, str) and built_at.strip():
        meta_lines.append(f"**Built:** {built_at.strip()}")

    lines: list[str] = [f"# {title}"]
    if meta_lines:
        lines.append("\\\n".join(meta_lines))
    lines.append("\n---\n")
    return "\n\n".join(lines)


def _escape_latex(value: str) -> str:
    replacements = {
        "\\": r"\\textbackslash{}",
        "{": r"\\{",
        "}": r"\\}",
        "#": r"\\#",
        "$": r"\\$",
        "%": r"\\%",
        "&": r"\\&",
        "_": r"\\_",
        "^": r"\\textasciicircum{}",
        "~": r"\\textasciitilde{}",
    }
    out = value
    for k, v in replacements.items():
        out = out.replace(k, v)
    return out


def _format_latex_context(context: dict[str, Any]) -> str:
    title = _escape_latex(str(context.get("title") or "").strip())
    authors = context.get("author")
    if isinstance(authors, list):
        authors_line = ", ".join(str(a) for a in authors if str(a).strip())
    else:
        authors_line = str(authors or "").strip()
    authors_line = _escape_latex(authors_line)

    snapshot_label = str(context.get("snapshot_label") or "").strip()
    version = str(context.get("build", {}).get("version") or "").strip()
    built_at = str(context.get("build", {}).get("built_at") or "").strip()

    parts: list[str] = [
        "% Generated by mcodex. Do not edit.",
        f"\\newcommand{{\\McodexTitle}}{{{title}}}",
        f"\\newcommand{{\\McodexAuthors}}{{{authors_line}}}",
        (f"\\newcommand{{\\McodexSnapshotLabel}}{{{_escape_latex(snapshot_label)}}}"),
        f"\\newcommand{{\\McodexVersion}}{{{_escape_latex(version)}}}",
        f"\\newcommand{{\\McodexBuiltAt}}{{{_escape_latex(built_at)}}}",
    ]
    return "\n".join(parts) + "\n"


def write_build_context(
    *,
    tmp_dir: Path,
    source_dir: Path,
    pipeline_name: str,
    version_label: str,
) -> BuildContextResult:
    """Create build context artifacts in the temp build directory.

    Writes:
    - build_context.yaml: merged metadata + optional snapshot + runtime
    - build_header.md: a human-friendly header for pandoc standalone builds
    - context.tex: macros used by the latexmk template
    """

    tmp_dir = tmp_dir.expanduser().resolve()
    source_dir = source_dir.expanduser().resolve()

    meta = load_metadata(source_dir / "metadata.yaml")
    snapshot = _load_optional_yaml(source_dir / "snapshot.yaml")

    authors = _authors_as_nicknames(meta)

    context: dict[str, Any] = dict(meta)
    context["author"] = authors

    if snapshot is not None:
        context["snapshot"] = snapshot
        label = snapshot.get("label")
        if isinstance(label, str) and label.strip():
            context["snapshot_label"] = label.strip()

    context["build"] = {
        "pipeline": pipeline_name,
        "version": version_label,
        "built_at": datetime.now().astimezone().isoformat(),
    }

    yaml_path = tmp_dir / "build_context.yaml"
    safe_dump_yaml(context, yaml_path)

    header_md_path = tmp_dir / "build_header.md"
    header_md_path.write_text(_format_header_md(context), encoding="utf-8")

    latex_context_path = tmp_dir / "context.tex"
    latex_context_path.write_text(
        _format_latex_context(context),
        encoding="utf-8",
    )

    return BuildContextResult(
        context=context,
        yaml_path=yaml_path,
        header_md_path=header_md_path,
        latex_context_path=latex_context_path,
    )
